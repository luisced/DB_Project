from rest_framework.response import Response
from rest_framework.decorators import api_view
from rest_framework.pagination import PageNumberPagination
import random
from django.db.models import Count, F, Func
from django.db import models
from ..serializers.cyberAttack_serializers import CyberAttackSerializer, AfectedUserSerializer, DeviceSerializer, GeolocalizationSerializer
from ..models import CyberAttack, AfectedUser, Device, Geolocalization

# GET all cyberAttacks
@api_view(['GET'])
def get_cyberAttacks(request):
    cyberAttacks = CyberAttack.objects.all()
    paginator = PageNumberPagination()
    paginator.page_size = 100
    result_page = paginator.paginate_queryset(cyberAttacks, request)
    serializer = CyberAttackSerializer(result_page, many=True)
    return paginator.get_paginated_response(serializer.data)

# GET single cyberAttack
@api_view(['GET'])
def get_cyberAttack(request, pk):
    try:
        cyberAttack = CyberAttack.objects.get(pk=pk)
        serializer = CyberAttackSerializer(cyberAttack, many=False)
        return Response(serializer.data)
    except CyberAttack.DoesNotExist:
        return Response({'error': 'CyberAttack not found'}, status=404)

# Frequency of Each Type of Attack
@api_view(['GET'])
def atypeFrequency(request):
    attackTypes = CyberAttack.objects.values('attackType').annotate(count=Count('attackType')).order_by('-count')
    return Response(attackTypes)

# Severity Levels of Attacks Over Time
@api_view(['GET'])
def attacks_by_severity(request):
    # Annotate data grouping by severity and the hour part of the timestamp
    attack_data = CyberAttack.objects.values(
        severity=F('severityLevel'),
        hour=ExtractHour('timestamp')
    ).annotate(
        count=Count('id')
    ).order_by('severity', 'hour')

    # Initialize a dictionary to hold all severity levels
    severity_dict = {}

    # Fill the dictionary with data for each severity level
    for attack in attack_data:
        severity = attack['severity']
        hour = attack['hour']
        count = attack['count']
        if severity not in severity_dict:
            severity_dict[severity] = {'id': severity, 'data': []}
        severity_dict[severity]['data'].append({'x': int(hour), 'y': count})

    # Convert the dictionary to a list as required
    result = list(severity_dict.values())

    return Response(result)


# Extracts only the hour part of the timestamp
class ExtractHour(Func):
    function = 'EXTRACT'
    template = '%(function)s(HOUR from %(expressions)s)'


# Devices Most Attacked
@api_view(['GET'])
def mostAttackedDevices(request):
    devices = CyberAttack.objects.values('device__web_browser', 'device__operative_system').annotate(count=Count('device')).order_by('-count')
    paginator = PageNumberPagination()
    paginator.page_size = 10
    result_page = paginator.paginate_queryset(devices, request)
    return paginator.get_paginated_response(result_page)

# IDS/IPS Alerts Detection
@api_view(['GET'])
def idsIpsAlerts(request):
    idsIps = CyberAttack.objects.values('idsIpsAlerts').annotate(count=Count('idsIpsAlerts')).order_by('-count')
    return Response(idsIps)

# Geographical Distribution of Attacks
@api_view(['GET'])
def geoLocation(request):
    geoLocations = CyberAttack.objects.values('geoLocation__city').annotate(count=Count('geoLocation')).order_by('-count')
    return Response(geoLocations)

# Correlation Between Attack Type and Action Taken
@api_view(['GET'])
def attackAction(request):
    attackActions = CyberAttack.objects.values('attackType', 'actionTaken').annotate(count=Count('attackType')).order_by('attackType', 'actionTaken')
    return Response(attackActions)

# Protocol Usage Frequency
@api_view(['GET'])
def protocolFrequency(request):
    protocols = CyberAttack.objects.values('protocol').annotate(count=Count('protocol')).order_by('-count')
    return Response(protocols)

# Alerts and Warnings Generated by Attacks
@api_view(['GET'])
def alertsWarnings(request):
    alerts = CyberAttack.objects.values('alertsWarnings').annotate(count=Count('alertsWarnings')).order_by('-count')
    return Response(alerts)

# GET all affectedUsers
@api_view(['GET'])
def get_afectedUsers(request):
    afectedUsers = AfectedUser.objects.all()
    paginator = PageNumberPagination()
    paginator.page_size = 500
    result_page = paginator.paginate_queryset(afectedUsers, request)
    serializer = AfectedUserSerializer(result_page, many=True)
    return paginator.get_paginated_response(serializer.data)

# GET all devices
@api_view(['GET'])
def get_devices(request):
    devices = Device.objects.all()
    paginator = PageNumberPagination()
    paginator.page_size = 500
    result_page = paginator.paginate_queryset(devices, request)
    serializer = DeviceSerializer(result_page, many=True)
    return paginator.get_paginated_response(serializer.data)

# GET all geolocalizations
@api_view(['GET'])
def get_geolocalizations(request):
    geolocalizations = Geolocalization.objects.all()
    paginator = PageNumberPagination()
    paginator.page_size = 500
    result_page = paginator.paginate_queryset(geolocalizations, request)
    serializer = GeolocalizationSerializer(result_page, many=True)
    return paginator.get_paginated_response(serializer.data)


@api_view(['GET'])
def unalerted_attacks_by_country(request):
    # Query to fetch and aggregate unalerted attacks by country
    attacks_data = CyberAttack.objects.filter(
        alertsWarnings=False,
        geoLocation__isnull=False
    ).values(
        country=F('geoLocation__city')  # Corrected to use 'locality'
    ).annotate(
        count=Count('id')
    ).order_by('-count')

    return Response(attacks_data)

@api_view(['GET'])
def attack_types_by_country(request):
    
    attack_types_data = CyberAttack.objects.filter(
        alertsWarnings=False,
        geoLocation__isnull=False
    ).values(
        'geoLocation__city',
        'attackType'
    ).annotate(
        count=Count('id')
    ).order_by('geoLocation__city', '-count')

    result = {}

    for item in attack_types_data:
        country = item['geoLocation__city']
        attack_type = item['attackType']
        if country not in result:
            result[country] = {'country': country}

        if attack_type not in result[country]:
            color_field = f'{attack_type}Color'
            result[country][attack_type] = item['count']
            result[country][color_field] = generate_random_hsl()

    # Convert the result dictionary to a list of dictionaries as required
    result_list = list(result.values())
    return Response(result_list)

def generate_random_hsl():
    hue = random.randint(0, 360)
    saturation = random.randint(50, 100)
    lightness = random.randint(40, 60)
    return f'hsl({hue}, {saturation}%, {lightness}%)'


'''

'''